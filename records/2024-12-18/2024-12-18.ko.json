[
  {
    "id": 42445037,
    "title": "FTC, 호텔 및 이벤트 티켓 가격의 숨겨진 추가 요금 금지",
    "originLink": "https://www.cnbc.com/2024/12/17/ftc-bans-hidden-junk-fees-in-hotel-event-ticket-prices-.html",
    "originBody": "",
    "commentLink": "https://news.ycombinator.com/item?id=42445037",
    "commentBody": "",
    "originSummary": [
      "FTC는 호텔 및 이벤트 티켓 가격에서 숨겨진 수수료를 금지하는 규칙을 시행하여 판매자가 총 비용을 사전에 공개하도록 요구하고 있습니다.",
      "이 이니셔티브는 소비자 비용을 불필요하게 증가시키는 불필요한 수수료를 제거하려는 바이든 대통령의 광범위한 노력의 일환입니다.",
      "규칙에 따르면 서비스 및 리조트 요금이 광고된 가격에 포함되어야 하며, 이는 소비자에게 상당한 시간을 절약할 수 있지만, 향후 행정부와 의회의 도전에 직면할 수 있습니다."
    ],
    "commentSummary": [
      "연방거래위원회(FTC)는 호텔 및 이벤트 티켓 가격에 숨겨진 불필요한 수수료를 금지하고, 모든 수수료를 소비자에게 사전에 공개하도록 의무화했습니다. 이 규제는 가격 투명성을 높이고 상인들의 오해의 소지가 있는 관행으로부터 소비자를 보호하기 위한 것입니다. 이 결정은 공정한 경쟁을 촉진하고 숨겨진 비용을 통한 소비자 착취를 방지하기 위한 규제의 필요성에 대한 논의를 시작했습니다."
    ],
    "points": 490,
    "commentCount": 480,
    "retryCount": 0,
    "time": 1734467767
  },
  {
    "id": 42447071,
    "title": "Ergo Chat – Go 언어로 작성된 현대적인 IRC 서버",
    "originLink": "https://github.com/ergochat/ergo",
    "originBody": "",
    "commentLink": "https://news.ycombinator.com/item?id=42447071",
    "commentBody": "",
    "originSummary": [
      "Ergo는 이전에 Oragono로 알려졌던 현대적인 인터넷 릴레이 채팅(IRC) 서버로, Go 프로그래밍 언어로 개발되어 설치 및 사용이 용이합니다.",
      "IRC 데몬(ircd), 서비스 프레임워크 및 바운서의 기능을 통합하며, IRCv3를 지원하고 YAML 구성 파일을 통해 사용자 정의할 수 있습니다.",
      "Ergo는 Ergonomadic IRC 데몬의 포크이며 Jeremy Latt, Edmund Huber, Daniel Oaks, Shivaram Lingamneni와 같은 개발자들의 기여를 포함하고 있습니다."
    ],
    "commentSummary": [
      "Ergo Chat은 Go로 개발된 현대적인 IRC(인터넷 릴레이 채팅) 서버로, 호스팅의 간편함, 최소한의 자원 사용, v3 채팅 기록 및 항상 켜져 있는 다중 클라이언트 지원과 같은 고급 기능으로 잘 알려져 있습니다.",
      "웹 클라이언트 접근을 용이하게 하는 내장 웹소켓 지원을 포함하고 있으며, 사용자가 IRC로 인식하지 못할 수 있는 현대적인 채팅 경험을 제공합니다.",
      "논의는 Discord와 같은 플랫폼에 비해 IRC의 개방형 프로토콜과 유연성을 강조하며, IRC의 지속적인 채팅 기록 부족에 대한 논쟁도 포함됩니다. 일부 사람들은 이를 일시적인 대화를 유지하기 위한 기능으로 봅니다."
    ],
    "points": 248,
    "commentCount": 113,
    "retryCount": 0,
    "time": 1734482779
  },
  {
    "id": 42448939,
    "title": "은 부적은 알프스 북쪽에서 기독교의 가장 오래된 증거입니다.",
    "originLink": "https://archaeologymag.com/2024/12/oldest-evidence-of-christianity-north-of-the-alps/",
    "originBody": "",
    "commentLink": "https://news.ycombinator.com/item?id=42448939",
    "commentBody": "",
    "originSummary": [],
    "commentSummary": [
      "프랑크푸르트에서 발견된 은 부적은 알프스 북쪽에서 기독교의 가장 오래된 증거로, 기원후 230-270년으로 거슬러 올라갑니다.",
      "이 부적에는 신약 성경과 전례 찬송인 트리사기온에 대한 언급을 포함하여 기독교 요소가 담긴 라틴어 비문이 새겨져 있습니다.",
      "이 발견은 지역 내 초기 기독교의 확산과 영향력을 이해하는 데 있어 중요하며, 지역 전통과의 통합을 강조합니다."
    ],
    "points": 199,
    "commentCount": 175,
    "retryCount": 0,
    "time": 1734510672
  },
  {
    "id": 42447053,
    "title": "XOR 텍스처 (2004)",
    "originLink": "https://lodev.org/cgtutor/xortexture.html",
    "originBody": "",
    "commentLink": "https://news.ycombinator.com/item?id=42447053",
    "commentBody": "",
    "originSummary": [
      "XOR 텍스처는 픽셀의 x 및 y 좌표에 XOR 연산을 적용하여 생성되며, 이는 간단하게 만들 수 있어 텍스처 매퍼를 테스트하는 데 유용합니다. XOR 텍스처는 과도한 사용으로 인해 데모나 게임에는 적합하지 않지만, 다양한 RGB 값을 사용하거나 HSV에서 RGB로 변환하여 다양한 색상 효과를 줄 수 있습니다. 유사한 텍스처는 AND 및 OR 연산을 사용하여 생성할 수 있으며, XOR은 비트가 다를 경우 1을 반환하고, AND는 두 비트가 모두 1일 경우, OR은 어느 비트든 1일 경우 1을 반환합니다."
    ],
    "commentSummary": [
      "한 사용자가 x86 어셈블리를 사용하여 XOR 텍스처를 생성한 경험을 설명했으며, 이는 독특한 시각적 효과를 만들어내어 유사한 기술에 대한 관심을 불러일으켰습니다.",
      "논의에서는 1960년대 PDP-1 컴퓨터의 시각적 효과인 'munching squares'를 언급하며 이러한 그래픽의 역사적 맥락을 강조했습니다.",
      "참가자들은 Lode의 컴퓨터 그래픽 튜토리얼을 포함한 자원과 경험을 교환하고, 해밍 거리 텍스처 및 창의적인 프로젝트를 위한 글리칭 알고리즘과 같은 관련 주제를 탐구했습니다."
    ],
    "points": 198,
    "commentCount": 46,
    "retryCount": 0,
    "time": 1734482604
  },
  {
    "id": 42446846,
    "title": "루비의 JSON 최적화, 1부",
    "originLink": "https://byroot.github.io/ruby/json/2024/12/15/optimizing-ruby-json-part-1.html",
    "originBody": "",
    "commentLink": "https://news.ycombinator.com/item?id=42446846",
    "commentBody": "",
    "originSummary": [
      "Ruby json gem의 유지 관리자는 성능 향상에 중점을 두어 Ruby에서 가장 빠른 JSON 파서 및 생성기를 만드는 것을 목표로 하고 있습니다. 이러한 개선은 oj와 같은 대안에 대한 의존도를 줄이는 것을 목표로 합니다. oj는 더 빠르지만, 몽키 패칭 및 불안정성 문제를 가지고 있습니다. 최적화에는 중복 검사 회피, 가능성이 높은 조건 우선 처리, 설정 비용 감소, 조회 테이블 사용 등이 포함되며, 그 결과 최대 30%의 속도 향상이 이루어졌습니다."
    ],
    "commentSummary": [
      "이 기사는 Ruby의 JSON 처리에서 성능 향상을 탐구하며, 구문 분석 시간과 simdjson과 같은 다른 라이브러리와의 비교를 다루고 있습니다.",
      "이는 Ruby에서 JSON을 최적화하는 데 있어 조회 테이블의 사용, SIMD(단일 명령, 다중 데이터) 명령어, C++ 대신 C99를 사용하는 제약 조건을 포함한 여러 도전 과제를 강조합니다.",
      "논의는 또한 JSON과 Ruby의 명명 규칙을 다루며, camelCase와 snake_case 변환을 처리하기 위한 제안을 제공하고, 후속 기사에서 추가적인 통찰력을 제공하는 시리즈의 일부입니다."
    ],
    "points": 196,
    "commentCount": 42,
    "retryCount": 0,
    "time": 1734480532
  }
]
